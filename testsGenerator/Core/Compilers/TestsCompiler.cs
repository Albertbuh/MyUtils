namespace Core.Compilers;

internal abstract class TestsCompiler
{
    protected abstract string TestAttributeIdentifier { get; }

    public virtual CompilationUnitSyntax GenerateCodeByItem(Core.Models.GenerateItem item) =>
        SyntaxFactory
            .CompilationUnit()
            .WithMembers(
                SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                    item.NamespaceItem != null
                        ? GenerateNamespace(item)
                            .WithMembers(
                                SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                                    GenerateClass(item)
                                )
                            )
                        : GenerateClass(item)
                )
            )
            .NormalizeWhitespace();

    
    protected FileScopedNamespaceDeclarationSyntax GenerateNamespace(
        Core.Models.GenerateItem item
    ) =>
        SyntaxFactory.FileScopedNamespaceDeclaration(
            SyntaxFactory.IdentifierName($"{item.NamespaceName}.Tests")
        );

    protected virtual ClassDeclarationSyntax GenerateClass(Core.Models.GenerateItem item)
    {
        var list = new List<MemberDeclarationSyntax>();
        foreach (var method in item.Methods)
        {
            var name = item.GetMethodName(method);
            if (!string.IsNullOrEmpty(name))
                list.Add(GenerateTestMethod(name));
        }
        return SyntaxFactory
            .ClassDeclaration($"{item.ClassName}_Tests")
            .WithModifiers(GenerateModifier(SyntaxKind.PublicKeyword))
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(list));
    }

    protected MemberDeclarationSyntax GenerateTestMethod(string name) =>
        SyntaxFactory
            .MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)),
                GenerateIdentifier(name)
            )
            .WithAttributeLists(GenerateAttributeList(this.TestAttributeIdentifier))
            .WithModifiers(GenerateModifier(SyntaxKind.PublicKeyword))
            .WithBody(GenerateBlock());

    protected SyntaxList<AttributeListSyntax> GenerateAttributeList(string identifier) =>
        SyntaxFactory.SingletonList<AttributeListSyntax>(
            SyntaxFactory.AttributeList(
                SyntaxFactory.SingletonSeparatedList<AttributeSyntax>(GenerateAttribute(identifier))
            )
        );

    protected AttributeSyntax GenerateAttribute(string name) =>
        SyntaxFactory.Attribute(GenerateIdentifierName(name));

    protected SyntaxTokenList GenerateModifier(SyntaxKind kind) =>
        SyntaxFactory.TokenList(SyntaxFactory.Token(kind));

    protected SyntaxToken GenerateIdentifier(string identifier) =>
        SyntaxFactory.Identifier(identifier);

    protected IdentifierNameSyntax GenerateIdentifierName(string identifier) =>
        SyntaxFactory.IdentifierName(identifier);

    protected SyntaxToken GenerateToken(SyntaxKind kind) => SyntaxFactory.Token(kind);

    protected BlockSyntax GenerateBlock()
    {
        var argument = SyntaxFactory.Argument(
            SyntaxFactory.LiteralExpression(
                SyntaxKind.StringLiteralExpression,
                SyntaxFactory.Literal("autogenerated")
            )
        );

        var invocationExpression = SyntaxFactory.InvocationExpression(
            SyntaxFactory.MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                SyntaxFactory.IdentifierName("Assert"),
                SyntaxFactory.IdentifierName("Fail")
            )
        );

        var expression = SyntaxFactory.ExpressionStatement(
            invocationExpression.WithArgumentList(
                SyntaxFactory.ArgumentList(
                    SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(argument)
                )
            )
        );

        return SyntaxFactory.Block(expression);
    }
}
