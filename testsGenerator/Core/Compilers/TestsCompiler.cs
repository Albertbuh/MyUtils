namespace Core.Compilers;

internal abstract class TestsCompiler
{
    protected abstract string TestAttributeIdentifier { get; }

    public virtual CompilationUnitSyntax GenerateCodeByItem(Core.Models.GenerateItem item)
    {
        return GenerateSimpleCode(item);
    }

    protected CompilationUnitSyntax GenerateSimpleCode(Core.Models.GenerateItem item) =>
        SyntaxFactory
            .CompilationUnit()
            .WithMembers(
                SyntaxFactory.SingletonList<MemberDeclarationSyntax>(
                    item.NamespaceItem != null ? 
                    GenerateNamespace(item)
                    .WithMembers(
                        SyntaxFactory.SingletonList<MemberDeclarationSyntax>(GenerateClass(item))
                    )
                    : GenerateClass(item)
                )
            )
            .NormalizeWhitespace();

    protected virtual SyntaxList<UsingDirectiveSyntax> GenerateUsings(Core.Models.GenerateItem item)
    {
        var usingList = new List<UsingDirectiveSyntax>();
        usingList.Add(GenerateUsing("Moq"));
        usingList.Add(GenerateUsing(item.NamespaceName!));
        return new SyntaxList<UsingDirectiveSyntax>(usingList);
    }

    protected UsingDirectiveSyntax GenerateUsing(string name) =>
        SyntaxFactory.UsingDirective(SyntaxFactory.IdentifierName(name));

    protected FileScopedNamespaceDeclarationSyntax GenerateNamespace(
        Core.Models.GenerateItem item
    ) =>
        SyntaxFactory
            .FileScopedNamespaceDeclaration(
                SyntaxFactory.IdentifierName($"{item.NamespaceName}.Tests")
            );

    protected virtual ClassDeclarationSyntax GenerateClass(Core.Models.GenerateItem item)
    {
        var list = new List<MemberDeclarationSyntax>();
        foreach (var method in item.Methods)
        {
            var name = item.GetMethodName(method);
            if (!string.IsNullOrEmpty(name))
                list.Add(GenerateTestMethod(name));
        }
        return SyntaxFactory
            .ClassDeclaration($"{item.ClassName}_Tests")
            .WithModifiers(GenerateModifier(SyntaxKind.PublicKeyword))
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(list));
    }

    protected FieldDeclarationSyntax GenerateField(
        string type,
        string name,
        SyntaxKind kind = SyntaxKind.PrivateKeyword
    ) =>
        SyntaxFactory
            .FieldDeclaration(
                SyntaxFactory
                    .VariableDeclaration(SyntaxFactory.IdentifierName(name))
                    .WithVariables(
                        SyntaxFactory.SingletonSeparatedList<VariableDeclaratorSyntax>(
                            (SyntaxFactory.VariableDeclarator(SyntaxFactory.Identifier(name)))
                        )
                    )
            )
            .WithModifiers(GenerateModifier(kind));

    protected MemberDeclarationSyntax GenerateTestMethod(string name) =>
        SyntaxFactory
            .MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.VoidKeyword)),
                GenerateIdentifier(name)
            )
            .WithAttributeLists(GenerateAttributeList(this.TestAttributeIdentifier))
            .WithModifiers(GenerateModifier(SyntaxKind.PublicKeyword))
            .WithBody(GenerateSimpleBlock());


    protected SyntaxList<AttributeListSyntax> GenerateAttributeList(string identifier) =>
        SyntaxFactory.SingletonList<AttributeListSyntax>(
            SyntaxFactory.AttributeList(
                SyntaxFactory.SingletonSeparatedList<AttributeSyntax>(GenerateAttribute(identifier))
            )
        );

    protected AttributeSyntax GenerateAttribute(string name) =>
        SyntaxFactory.Attribute(GenerateIdentifierName(name));

    protected SyntaxTokenList GenerateModifier(SyntaxKind kind) =>
        SyntaxFactory.TokenList(SyntaxFactory.Token(kind));

    protected SyntaxToken GenerateIdentifier(string identifier) =>
        SyntaxFactory.Identifier(identifier);

    protected IdentifierNameSyntax GenerateIdentifierName(string identifier) =>
        SyntaxFactory.IdentifierName(identifier);

    protected SyntaxToken GenerateToke(SyntaxKind kind) => SyntaxFactory.Token(kind);

    protected BlockSyntax GenerateSimpleBlock()
    {
        var argument = SyntaxFactory.Argument(
            SyntaxFactory.LiteralExpression(
                SyntaxKind.StringLiteralExpression,
                SyntaxFactory.Literal("autogenerated")
            )
        );

        var invocationExpression = SyntaxFactory.InvocationExpression(
            SyntaxFactory.MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                SyntaxFactory.IdentifierName("Assert"),
                SyntaxFactory.IdentifierName("Fail")
            )
        );

        var expression = SyntaxFactory.ExpressionStatement(
            invocationExpression.WithArgumentList(
                SyntaxFactory.ArgumentList(
                    SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(argument)
                )
            )
        );

        return SyntaxFactory.Block(expression);
    }

}
